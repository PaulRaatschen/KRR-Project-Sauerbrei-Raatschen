"""Imports"""
from importlib.resources import path
from msilib.schema import Control
from typing import List, Dict, Union, Tuple, Callable
from clingo import Symbol, Control, Model, Number, Function
from math import inf
from os import path

"""
This class defines solution and plan objects used to store the plans obtained by the solvers classes in this directory.
"""


WORKING_DIR : str = path.abspath(path.dirname(__file__))
ENCODING_DIR : str = path.join(WORKING_DIR,'encodings')
SAPF_FILE : str = path.join(ENCODING_DIR,'single_agent_pf_nc.lp')

class Plan: 
    """
    Stores a plan for a single agent.

    Attributes:
        occurs : List[Symbol]
            Occur atoms for the reconversion to a asprilo file.
        positions : List[Symbol]
            Position atoms for conflict detection.
        constaints : List[Symbol]
            Constraint atoms for the agent (CBS only).
        cost : int
            Sum of costs for the path.
        goal : Symbol
            Goal atom of the agent.
        initial : Symbol
            Position atom at time 0 of the agent

    Methods:  
        clear(self)
            Deletes path and sets cost to zero.
    """

    def __init__(self,occurs : List[Symbol] = None, positions : List[Symbol] = None, constraints : List[Symbol] = None, cost : int = 0, goal : Symbol = None, initial : Symbol = None):
        self.occurs = occurs if occurs else []
        self.positions = positions if positions else []
        self.constraints = constraints if constraints else []
        self.cost = cost
        self.goal = goal
        self.initial = initial

    def clear(self) -> None:
        """
            Deletes path and sets cost to zero.
        """
        self.occurs = []
        self.positions = []
        self.cost = 0

class Solution:
    """
    Stores the plans obtained by a solver, as well as instance and solution information.
    Provides functions to compute solution statistics. 

    Attributes:
        agents : List[int]
            List of the 1..n agents in the instance.
        inits : List[Symbol]
            Init atoms of the instance file.
        instance_atoms : List[Symbol]
            Atoms describing the instance generated by the preprocessing aps file.
        plans : Dict[int,Plan]
            Contains the plans for all agents.
        initial_plans : Dict[int,Plan]
            Contains the shortest path plans (without conflict detection) for all agents.
        num_of_nodes : int
            Number of nodes of the instance.
        makespan : int
            Makespan i.e. maximum horizon of the paths in plans.
        cost : int
            Sum of cost i.e. sum of horizons of the paths in plans.
        execution_time : float
            Time to solver took to find a solution in seconds. 
        satisfied : bool
            True if solution is valid, else False.


    Methods:
        clear_plans(self) -> None
            Clears the plans for all agents.
        clear_plan(self,agent : int) -> None
            Clears the plan for provided agent.
        save(self, filepath : str)
            Saves the solution to a file in asprilo format.
        get_initial_plans(self) -> List[Plan]
            Returns the shortest path plans (without conflict detection) for all agents 
        get_initial_plan_info(self) -> Dict[str,Union[List[Plan],int]]
            Returns shortest path plans (without conflict detection) and soc, makespan information
        get_soc(self) -> int
            Computes sum of cost for the paths in plans.
        get_makespan(self) -> int
            Computes makespan for the paths in plans.
        get_total_moves(self) -> int
            Computes the total number of moves for the paths in plans.
        get_norm_total_moves(self) -> float
            Computes total moves of the solution divided by total moves of the initial plans.
        get_norm_soc(self) -> float
            Computes soc of the solution divided by soc of the initial plans.
        get_density(self) -> float
            Computes number of robots + shelfs divided by number of nodes for the instance.
        save_initial_plans(self,filepath : str) -> None
            Saves the initial plans to a file in asprilo format.
    """

    def __init__(self,agents : List[int] = None,inits : List[Symbol] = None, instance_atoms : List[Symbol] = None, plans : Dict[int,Plan] = None, num_of_nodes : int = 0):
        self.agents = agents if agents else []
        self.inits = inits if inits else []
        self.instance_atoms = instance_atoms if instance_atoms else []
        self.plans = plans if plans else {}
        self.initial_plans : Dict[int,Plan] = {}
        self.num_of_nodes = num_of_nodes
        self.makespan : int = 0
        self.cost : int = 0
        self.execution_time : float = 0.0
        self.satisfied : bool = False

    def clear_plans(self) -> None:
        """
        Clears the position and occurs atoms from all plans in the solution object
        """
        for plan in self.plans.values():
            plan.clear()


    def clear_plan(self,agent : int) -> None:
        """
        Clears the position and occurs atoms from the plan of agent
        """
        self.plans[agent].clear()


    def save(self, filepath : str) -> None:
        """
        Saves the occurs atoms in plans to filepath.lp
        """
        with open(filepath, 'w', encoding='utf-8') as file:
            for init in self.inits:
                file.write(f"{init}. ")
            for plan in self.plans.values():
                for occur in plan.occurs:
                    file.write(f"{occur}. ")


    def get_initial_plans(self) -> Dict[int,Plan]:
        """
        Computes the shortest plans for all agents without conflict evasion.

        Side effet:
            Updates initial plans with the obtained plans

        Returns:
            Dictionary of all agents (key) and their initial plan (value)
        """

        ctl : Control

        def model_parser(model : Model,agent : int) -> bool:
            for atom in model.symbols(shown=True):
                if atom.name == 'occurs':
                    self.initial_plans[agent].occurs.append(atom)
                elif atom.name == 'position' and atom.arguments[0].number == agent:
                    self.initial_plans[agent].positions.append(atom)
            return False

        if not self.initial_plans:
            for agent in self.agents:
                self.initial_plans[agent] = Plan(goal=self.plans[agent].goal,initial=self.plans[agent].initial)
                ctl = Control(arguments=['-Wnone',f'-c r={agent}']) 
                ctl.load(SAPF_FILE)

                with ctl.backend() as backend:
                    fact = backend.add_atom(self.initial_plans[agent].goal)
                    backend.add_rule([fact])
                    fact = backend.add_atom(self.initial_plans[agent].initial)
                    backend.add_rule([fact])
                    for atom in self.instance_atoms:
                        fact = backend.add_atom(atom)
                        backend.add_rule([fact])
                    
                self.initial_plans[agent].cost = self.incremental_solving(ctl,self.num_of_nodes,lambda m, a=agent : model_parser(m,a))

        return self.initial_plans
        

    def get_initial_plan_info(self) -> Dict[str,Union[Dict[int,Plan],int]]:
        """
        Computes the initial plans if not already present and returns additional soc and makespan information

        Side effect:
            inital plans are updated if not aready present

        Returns:
            Dictionary containing initial plan dictionary, soc and makespan of initial plans
        """
        result : Dict[str,Union[Dict[int,Plan],int]] = { 'plans' : {}, 'soc': 0, 'makespan' : 0 }
        soc : int = 0
        makespan : int = 0

        if not self.initial_plans:
            self.get_initial_plans()

        result['plans'] = self.initial_plans

        for plan in self.initial_plans.values():
            soc += plan.cost
            makespan = max(makespan,plan.cost)

        result['soc'] = soc
        result['makespan'] = makespan

        return result

    def get_soc(self) -> int:
        """
        Returns sum of cost for the plans of the solution
        """
        if self.cost > 0:
            return self.cost
        else:
            cost : int = 0
            for plan in self.plans.values():
                cost += plan.cost
            return cost


    def get_makespan(self) -> int:
        """
        Returns makespan for the plans of the solution
        """
        if self.makespan == 0:
            for plan in self.plans.values():
                self.makespan = max(self.makespan,plan.cost)

        return self.makespan

    def get_total_moves(self) -> int:
        """
        Returns the total number of moves for the plans of the solution
        """
        total_moves : int = 0

        for plan in self.plans.values():
            total_moves += len(plan.occurs)

        return total_moves

    def get_norm_total_moves(self) -> float:
        """
        Returns total numer of moves divided by the total number of moves of the initial plans
        """
        if not self.initial_plans.values():
            self.get_initial_plans()
        
        total : int = 0

        for plan in self.initial_plans.values():
            total += len(plan.occurs)

        return self.get_total_moves() / total

    def get_norm_soc(self) -> float:
        """
        Returns sum of cost divided by the sum of costs of the initial plans
        """
        info : Dict[str,Union[List[Plan],int]] = self.get_initial_plan_info()

        return self.get_soc() / info['soc']

    def get_norm_makespan(self) -> float:
        """
        Returns makespan divided by the makespan of the initial plans
        """
        info : Dict[str,Union[List[Plan],int]] = self.get_initial_plan_info()

        return self.get_makespan() / info['makespan']
    
    def get_density(self) -> float:
        """
        Returns the number of occupied nodes (robot or shelf) divided by total number of nodes
        """
        return len(self.agents) * 2 / (self.num_of_nodes)

    def save_initial_plans(self,filepath : str) -> None:
        """
        Saves the occurs atoms of the initial plans to filepath.lp
        """
        if not self.initial_plans:
            self.get_initial_plans()

        with open(filepath,'w',encoding='utf-8') as file:
                for plan in self.initial_plans.values():
                    for atom in plan.occurs:
                        file.write(f'{atom}.\n')
        
    @staticmethod   
    def incremental_solving(ctl : Control, max_horizon : int, model_parser : Callable[[Model],bool]) -> int:
        """
        Helper method for the multishot asp pathfinding

        Args:
            ctl : Clingo control object with preloaded facts and rules.
            max_horizon : Upper bound for the amount of clingo calls i.e lenght of the path.
            model_parser : Function passed to the Control.solve() call to parse the resulting model.

        Returns:
            Number of clingo calls i.e. pathlength if a path was found or max_horizon + 1 if not.
        """

        ret, step = None, 0

        while((step < max_horizon) and (ret is None or (step < max_horizon and not ret.satisfiable))):
            parts = []
            parts.append(("check", [Number(step)]))
            if step > 0:
                ctl.release_external(Function("query", [Number(step - 1)]))
                parts.append(("step", [Number(step)]))
            else:
                parts.append(("base", []))
            ctl.ground(parts)
            ctl.assign_external(Function("query", [Number(step)]), True)
            ret, step = ctl.solve(on_model=model_parser), step + 1   

        return inf  if not ret or (not ret.satisfiable) else step - 1   
    
    

